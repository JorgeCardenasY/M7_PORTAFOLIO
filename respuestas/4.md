# Entendiendo las Migraciones en Django: Una Comparación Práctica

Para entender cómo Django maneja los cambios en la base de datos, vamos a simular un escenario real. Aunque no hemos podido ejecutar las migraciones directamente en el proyecto `preg_2/bi` por problemas con la estructura de archivos, podemos ilustrar el proceso completo con un ejemplo práctico y conceptual.

Imaginemos que en nuestra aplicación `bi`, dentro de `preg_2/bi/models.py`, comenzamos con un modelo simple llamado `Reporte`.

## Escenario Inicial: El Primer Modelo

Nuestro archivo `preg_2/bi/models.py` contiene lo siguiente:

```python
# preg_2/bi/models.py

from django.db import models

class Reporte(models.Model):
    titulo = models.CharField(max_length=200)
    autor = models.CharField(max_length=100)
    fecha_creacion = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.titulo
```

### Paso 1: Creación de la Migración Inicial (`makemigrations`)

Al tener un nuevo modelo, el primer paso es pedirle a Django que genere el archivo de migración. Ejecutaríamos el siguiente comando:

```bash
python manage.py makemigrations bi
```

Django analizaría `models.py`, vería el nuevo modelo `Reporte` y crearía un nuevo archivo dentro de `preg_2/bi/migrations/` llamado `0001_initial.py`.

**Contenido de `0001_initial.py` (simulado):**

```python
# Generated by Django

from django.db import migrations, models

class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name='Reporte',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('titulo', models.CharField(max_length=200)),
                ('autor', models.CharField(max_length=100)),
                ('fecha_creacion', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]
```

**Explicación:**

*   `operations`: Esta es la lista de operaciones que Django debe realizar.
*   `migrations.CreateModel`: Esta operación le dice a Django que debe crear una nueva tabla en la base de datos para el modelo `Reporte`.
*   `fields`: Define todas las columnas que tendrá la tabla, incluyendo el `id` que Django añade automáticamente como clave primaria.

## Escenario 2: Modificando el Modelo

Ahora, supongamos que necesitamos añadir un campo para saber si el reporte está publicado o no. Modificamos nuestro `models.py`:

```python
# preg_2/bi/models.py (modificado)

from django.db import models

class Reporte(models.Model):
    titulo = models.CharField(max_length=200)
    autor = models.CharField(max_length=100)
    fecha_creacion = models.DateTimeField(auto_now_add=True)
    publicado = models.BooleanField(default=False) # <-- Nuevo campo añadido

    def __str__(self):
        return self.titulo
```

### Paso 2: Creación de la Segunda Migración (`makemigrations`)

Volvemos a ejecutar el mismo comando:

```bash
python manage.py makemigrations bi
```

Django comparará el estado actual de `models.py` con el estado registrado en la última migración (`0001_initial.py`). Detectará que hemos añadido el campo `publicado` y creará un nuevo archivo de migración, por ejemplo, `0002_reporte_publicado.py`.

**Contenido de `0002_reporte_publicado.py` (simulado):**

```python
# Generated by Django

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('bi', '0001_initial'), # <-- ¡Importante! Depende de la migración anterior
    ]

    operations = [
        migrations.AddField(
            model_name='reporte',
            name='publicado',
            field=models.BooleanField(default=False),
        ),
    ]
```

## Comparación y Propagación de Cambios

Al comparar las dos migraciones, vemos claramente la evolución de nuestro esquema:

*   **Migración 1 (`0001_initial.py`):** Se enfoca en **crear** la estructura inicial. Su operación principal es `CreateModel`.
*   **Migración 2 (`0002_reporte_publicado.py`):** Se enfoca en **modificar** la estructura existente. Su operación principal es `AddField`. Nota clave es la línea `dependencies`, que le dice a Django que esta migración solo puede aplicarse después de que la `0001_initial` haya sido aplicada. Esto asegura un orden correcto.

### Paso 3: Aplicando los Cambios a la Base de Datos (`migrate`)

Hasta ahora, solo hemos creado los "planos" de los cambios. No hemos tocado la base de datos. Para propagar estos cambios, ejecutamos:

```bash
python manage.py migrate bi
```

**¿Qué hace Django?**

1.  Revisa la tabla `django_migrations` en la base de datos para ver qué migraciones ya se han aplicado.
2.  Si `0001_initial` no ha sido aplicada, la lee, traduce la operación `CreateModel` a una sentencia SQL (`CREATE TABLE bi_reporte ...`) y la ejecuta en la base de datos.
3.  Luego, registra `0001_initial` en la tabla `django_migrations`.
4.  A continuación, ve que `0002_reporte_publicado` es la siguiente. Lee la operación `AddField`, la traduce a SQL (`ALTER TABLE bi_reporte ADD COLUMN publicado ...`) y la ejecuta.
5.  Finalmente, registra `0002_reporte_publicado` en la tabla `django_migrations`.

De esta manera, las migraciones actúan como un sistema de control de versiones para el esquema de tu base de datos, permitiendo que los cambios en tus modelos de Django se propaguen de manera ordenada, predecible y reversible.