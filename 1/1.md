# Integración de Django con Bases de Datos: Una Guía para Estudiantes

## Características Fundamentales de la Integración de Django con Bases de Datos

Django está diseñado para hacer que trabajar con bases de datos sea  sencillo y eficiente sin repetir mucho código (filosofía DRY: Don't Repeat Yourself). Aquí algunas características claves:

1.  **ORM (Object-Relational Mapper):** En lugar de escribir SQL puro (_Structured Query Language_) para interactuar con tu base de datos, Django permite trabajar con objetos Python. Esto se traduce en menos errores, en tener un código más legible y una curva de aprendizaje más suave.
2.  **Soporte para Múltiples Bases de Datos:** Django no nos ata a una sola base de datos. Es súper flexible y puede conectarse a una variedad de sistemas populares (Por defecto implementa SQLite, pero se puede configurar para usar PostgreSQL, MySQL, Oracle, etc).
3.  **Migraciones:** Las migraciones son archivos que Django genera automáticamente para registrar los cambios en tus modelos (que son la representación de tus tablas en Python) y aplicarlos a la base de datos de forma controlada.
4.  **Abstracción de la Base de Datos:** Django _abstrae_ las complejidades de cada sistema de base de datos. Esto significa que, en gran medida, se puede escribir el mismo código Python para interactuar con SQLite, PostgreSQL o MySQL, y Django se encarga de _traducir_ esas operaciones al lenguaje SQL específico de cada base de datos.

## Cómo Django se Integra con Diferentes Sistemas de Bases de Datos

Django puede trabajar con:

*   **SQLite:** Es la base de datos por defecto de Django. Es un sistema de base de datos ligero y basado en archivos, perfecto mpara el desarrollo local y proyectos pequeños. No necesita un servidor separado.
*   **PostgreSQL:** Una base de datos relacional muy potente y robusta, ideal para aplicaciones grandes y complejas que requieren alta concurrencia y características avanzadas.
*   **MySQL/MariaDB:** Opciones populares para aplicaciones de todos los tamaños.
*   **Oracle:** Principalmente utilizada para entornos empresariales que ya utilizan esta base de datos.

La idea más relevante es que se puede usar el mismo código Python para interactuar con los datos , dejando la utilización de código SQL acsi exclusivamente para modo RAW (_Raw SQL_).

## Cómo Django Maneja las Conexiones y Operaciones a Través de su ORM

Como mencionamos anteriormente, el ORM de Django es tu puente entre código Python y la base de datos: De este modo, a través de la definición de un  `Modelo` en Django, se está, esencialmente, creando una plantilla para una tabla en tu base de datos.

Por ejemplo, si se tiene un modelo `Producto`:

```python
# myapp/models.py
from django.db import models

class Producto(models.Model):
    nombre = models.CharField(max_length=100)
    precio = models.DecimalField(max_digits=10, decimal_places=2)
    stock = models.IntegerField(default=0)

    def __str__(self):
        return self.nombre
```

Con este modelo, el ORM te permite hacer cosas como:

*   **Crear un nuevo producto:**
    ```python
    producto = Producto(nombre="Laptop", precio=1200.00, stock=10)
    producto.save() # Guarda el objeto en la BBDD
    ```
*   **Consultar productos:**
    ```python
    todos_los_productos = Producto.objects.all() # Solicitar todos los productos
    laptop = Producto.objects.get(nombre="Laptop") # Solicitar un producto en específico
    productos_caros = Producto.objects.filter(precio__gt=1000) # Filtra por precio
    ```
*   **Actualizar un producto:**
    ```python
    laptop.precio = 1150.00
    laptop.save() # Actualiza el precio en la base de datos
    ```
*   **Eliminar un producto:**
    ```python
    laptop.delete() # Elimina el producto de la base de datos
    ```

El ORM se encarga de abrir y cerrar las conexiones a la base de datos.

## Ejemplo: Configuración del `settings.py` para Conectar Django con una Base de Datos

El archivo `settings.py` cetraliza la configuración del proyecto Django. Así, por defecto, cuando se crea un proyecto Django, `settings.py` ya viene configurado para usar SQLite:

```python
# myproject/settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3', # BASE_DIR es la ruta a la raíz de tu proyecto
    }
}
```

**Explicación:**

*   `'default'`: Es el nombre de la conexión a la base de datos. Se puede especificar más de una conexión si el proyecto lo requiriese.
*   `'ENGINE'`: Le dice a Django qué tipo de base de datos estamos usando.
    *   `'django.db.backends.sqlite3'` para SQLite.
    *   `'django.db.backends.postgresql'` para PostgreSQL.
    *   `'django.db.backends.mysql'` para MySQL.
*   `'NAME'`: Para SQLite, es la ruta al archivo de la base de datos.

### Configurando PostgreSQL

Si el proyecto requiere usar PostgreSQL, se debe instalar psycopg2 (con `pip install psycopg2-binary`) e importar:

```python
import psycopg2
```
en el encabezado del fichero `settings.py`.

Luego, en la sección `DATABASES` en  `settings.py`:

```python
# myproject/settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'nombre_de_tu_base_de_datos', # Nombre de BBDD PostgreSQL
        'USER': 'tu_usuario_de_postgres',     # Usuario PostgreSQL
        'PASSWORD': 'tu_contraseña_de_postgres', # Contraseña
        'HOST': 'localhost',                  # URL del Servidor(ej. 'localhost' o una IP)
        'PORT': '',                           # Puerto de PostgreSQL (usualmente 5432)
    }
}
```

### Configurando MySQL

Para MySQL se necesitaría instalar `mysqlclient` con `pip install mysqlclient`!):

```python
# myproject/settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'nombre_de_tu_base_de_datos',
        'USER': 'tu_usuario_de_mysql',
        'PASSWORD': 'tu_contraseña_de_mysql',
        'HOST': 'localhost',
        'PORT': '', # Puerto MySQL (3306, predeterminadamente)
    }
}
```

### Gestión de Conexiones

Django gestiona las conexiones a la base de datos de forma automática: Cuando la aplicación necesita interactuar con la base de datos (tal es el caso de hacer una consulta con el ORM), Django abre una nueva conexión si lo requiriese. Una vez que la operación termina, la conexión se devuelve al pool para ser reutilizada por otras solicitudes, lo que reduce la sobrecarga de abrir y cerrar conexiones constantemente.

Con todo, y a mayor abundamiento, la integración de Django con bases de datos es una de sus características más poderosas, _nos_ permite a los desarrolladores manterner el foco  en la lógica de nuestra aplicación en lugar de en las complejidades de la gestión de bases de datos con un lenguaje distinto al de python/Django.

## Conclusión:
# ¡A seguir aprendiendo!

<br>

> jorge@elabs.cl